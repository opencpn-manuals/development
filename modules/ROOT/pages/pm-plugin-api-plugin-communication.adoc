= Plugin Communication

This chapter explains how plugins can communicate with each other and with the OpenCPN core application. Plugin communication allows for sharing data, coordinating actions, and creating plugin ecosystems.

== Overview

OpenCPN provides a messaging system that allows plugins to send and receive messages. This system enables:

* Communication between plugins
* Publishing and subscribing to data streams
* Coordinating actions between plugins
* Creating extensible plugin ecosystems

== Plugin Messaging Capability

To participate in plugin messaging, a plugin must declare the `WANTS_PLUGIN_MESSAGING` capability:

[source,cpp]
----
int MyPlugin::Init(void) {
    // Initialize resources
    // ...
    
    // Return capabilities
    return WANTS_PLUGIN_MESSAGING;
}
----

== Receiving Messages

To receive messages, your plugin must implement the `SetPluginMessage()` method:

[source,cpp]
----
void MyPlugin::SetPluginMessage(wxString &message_id, wxString &message_body) {
    // Process the message based on its ID
    if (message_id == _T("OCPN_WPT_ARRIVING")) {
        // Handle waypoint arrival message
        // message_body contains waypoint information
        ProcessWaypointArrival(message_body);
    }
    else if (message_id == _T("OCPN_ROUTE_ACTIVATED")) {
        // Handle route activation message
        // message_body contains route information
        ProcessRouteActivation(message_body);
    }
    else if (message_id == _T("MY_CUSTOM_MESSAGE")) {
        // Handle custom message from another plugin
        ProcessCustomMessage(message_body);
    }
}
----

== Sending Messages

To send a message to other plugins, use the `SendPluginMessage()` function:

[source,cpp]
----
void MyPlugin::SendMyMessage() {
    // Create message ID and body
    wxString message_id = _T("MY_PLUGIN_UPDATE");
    wxString message_body = _T("{\"status\":\"active\",\"data\":\"42\"}");
    
    // Send the message
    SendPluginMessage(message_id, message_body);
}
----

All plugins that have declared the `WANTS_PLUGIN_MESSAGING` capability will receive this message through their `SetPluginMessage()` method.

== Message Format Conventions

While the plugin messaging system doesn't enforce a specific format for message bodies, several conventions have emerged:

=== JSON Format

JSON is a popular format for structured messages:

[source,cpp]
----
wxString message_body = _T("{\"command\":\"update\",\"params\":{\"lat\":47.6,\"lon\":-122.3}}");
----

Parsing JSON messages:

[source,cpp]
----
#include <wx/json_defs.h>
#include <wx/jsonreader.h>
#include <wx/jsonwriter.h>

void MyPlugin::ProcessJsonMessage(const wxString &message_body) {
    wxJSONValue root;
    wxJSONReader reader;
    
    int errors = reader.Parse(message_body, &root);
    if (errors > 0) {
        // Handle parsing error
        return;
    }
    
    // Extract data from JSON
    if (root.HasMember(_T("command"))) {
        wxString command = root[_T("command")].AsString();
        
        if (command == _T("update")) {
            // Process update command
            if (root[_T("params")].HasMember(_T("lat")) && 
                root[_T("params")].HasMember(_T("lon"))) {
                
                double lat = root[_T("params")][_T("lat")].AsDouble();
                double lon = root[_T("params")][_T("lon")].AsDouble();
                
                // Process lat/lon
                // ...
            }
        }
    }
}
----

=== Simple Key-Value Format

For simpler messages, a key-value format can be used:

[source,cpp]
----
wxString message_body = _T("lat=47.6;lon=-122.3;spd=5.2;cog=120");
----

Parsing key-value messages:

[source,cpp]
----
void MyPlugin::ProcessKeyValueMessage(const wxString &message_body) {
    // Split by semicolons
    wxArrayString pairs = wxStringTokenize(message_body, _T(";"));
    
    // Initialize variables
    double lat = 0.0, lon = 0.0, spd = 0.0, cog = 0.0;
    
    // Process each key-value pair
    for (size_t i = 0; i < pairs.GetCount(); i++) {
        wxArrayString pair = wxStringTokenize(pairs[i], _T("="));
        
        if (pair.GetCount() == 2) {
            wxString key = pair[0];
            wxString value = pair[1];
            
            if (key == _T("lat")) value.ToDouble(&lat);
            else if (key == _T("lon")) value.ToDouble(&lon);
            else if (key == _T("spd")) value.ToDouble(&spd);
            else if (key == _T("cog")) value.ToDouble(&cog);
        }
    }
    
    // Process extracted values
    // ...
}
----

=== XML Format

For more complex structured data, XML can be used:

[source,cpp]
----
wxString message_body = _T("<data><position lat=\"47.6\" lon=\"-122.3\"/><speed value=\"5.2\"/></data>");
----

Parsing XML messages:

[source,cpp]
----
#include <wx/xml/xml.h>

void MyPlugin::ProcessXmlMessage(const wxString &message_body) {
    wxStringInputStream stream(message_body);
    wxXmlDocument doc;
    
    if (!doc.Load(stream)) {
        // Handle parsing error
        return;
    }
    
    wxXmlNode *root = doc.GetRoot();
    if (root && root->GetName() == _T("data")) {
        // Process data node
        wxXmlNode *child = root->GetChildren();
        while (child) {
            if (child->GetName() == _T("position")) {
                // Get position attributes
                double lat = 0.0, lon = 0.0;
                wxString lat_str = child->GetAttribute(_T("lat"), _T("0"));
                wxString lon_str = child->GetAttribute(_T("lon"), _T("0"));
                
                lat_str.ToDouble(&lat);
                lon_str.ToDouble(&lon);
                
                // Process position
                // ...
            }
            else if (child->GetName() == _T("speed")) {
                // Get speed attribute
                double spd = 0.0;
                wxString spd_str = child->GetAttribute(_T("value"), _T("0"));
                
                spd_str.ToDouble(&spd);
                
                // Process speed
                // ...
            }
            
            child = child->GetNext();
        }
    }
}
----

== Standard Message IDs

OpenCPN defines several standard message IDs for common events. Plugins can listen for these messages to be notified of system events.

=== Core OpenCPN Messages

[cols="1,3"]
|===
|Message ID |Description

|`OCPN_WPT_ARRIVED`
|Sent when the vessel arrives at a waypoint. Message body contains waypoint information.

|`OCPN_ROUTE_ACTIVATED`
|Sent when a route is activated. Message body contains route information.

|`OCPN_ROUTE_DEACTIVATED`
|Sent when a route is deactivated. Message body contains route information.
|===

=== Plugin-to-Plugin Communication

When creating messages for plugin-to-plugin communication, follow these naming conventions:

* Use a prefix based on your plugin name to avoid conflicts
* Make message IDs descriptive of their purpose
* Consider versioning for evolving message formats

Example naming scheme:

[source,cpp]
----
// Weather plugin messages
wxString MSG_WEATHER_UPDATE = _T("WEATHER_PLUGIN_UPDATE_V1");
wxString MSG_WEATHER_FORECAST = _T("WEATHER_PLUGIN_FORECAST_V1");

// Navigation plugin messages
wxString MSG_NAV_POSITION = _T("NAV_PLUGIN_POSITION_V1");
wxString MSG_NAV_DESTINATION = _T("NAV_PLUGIN_DESTINATION_V1");
----

== Plugin Communication Patterns

=== Publisher-Subscriber Pattern

In this pattern, one plugin publishes data that other plugins can subscribe to:

**Publisher Plugin:**

[source,cpp]
----
// Weather plugin publishing forecast data
void WeatherPlugin::PublishForecast() {
    // Create forecast data
    wxString forecast_data = CreateForecastJson();
    
    // Publish to subscribers
    SendPluginMessage(_T("WEATHER_FORECAST_V1"), forecast_data);
}
----

**Subscriber Plugin:**

[source,cpp]
----
// Navigation plugin subscribing to weather forecasts
void NavigationPlugin::SetPluginMessage(wxString &message_id, wxString &message_body) {
    if (message_id == _T("WEATHER_FORECAST_V1")) {
        // Process weather forecast data
        ProcessWeatherForecast(message_body);
    }
}
----

=== Request-Response Pattern

In this pattern, one plugin requests information from another:

**Requester Plugin:**

[source,cpp]
----
// Request current weather data
void NavigationPlugin::RequestWeatherData() {
    // Create a unique request ID
    m_request_id = wxDateTime::Now().GetTicks();
    
    // Build request message
    wxString request = wxString::Format(
        _T("{\"request_id\":%ld,\"type\":\"current_weather\",\"lat\":%.6f,\"lon\":%.6f}"),
        m_request_id, m_current_lat, m_current_lon);
    
    // Send request
    SendPluginMessage(_T("WEATHER_DATA_REQUEST"), request);
}

// Handle response
void NavigationPlugin::SetPluginMessage(wxString &message_id, wxString &message_body) {
    if (message_id == _T("WEATHER_DATA_RESPONSE")) {
        // Parse response to get request_id
        wxJSONValue root;
        wxJSONReader reader;
        
        int errors = reader.Parse(message_body, &root);
        if (errors > 0) return;
        
        // Check if this is our response
        if (root.HasMember(_T("request_id")) && 
            root[_T("request_id")].AsLong() == m_request_id) {
            
            // Process weather data
            ProcessWeatherResponse(root);
        }
    }
}
----

**Responder Plugin:**

[source,cpp]
----
// Handle request and send response
void WeatherPlugin::SetPluginMessage(wxString &message_id, wxString &message_body) {
    if (message_id == _T("WEATHER_DATA_REQUEST")) {
        // Parse request
        wxJSONValue request_root;
        wxJSONReader reader;
        
        int errors = reader.Parse(message_body, &request_root);
        if (errors > 0) return;
        
        // Extract request parameters
        if (request_root.HasMember(_T("request_id")) &&
            request_root.HasMember(_T("type")) &&
            request_root.HasMember(_T("lat")) &&
            request_root.HasMember(_T("lon"))) {
            
            long request_id = request_root[_T("request_id")].AsLong();
            wxString type = request_root[_T("type")].AsString();
            double lat = request_root[_T("lat")].AsDouble();
            double lon = request_root[_T("lon")].AsDouble();
            
            // Generate weather data for the requested location
            wxString weather_data = GenerateWeatherData(type, lat, lon);
            
            // Create response
            wxJSONValue response_root;
            response_root[_T("request_id")] = request_id;
            response_root[_T("type")] = type;
            response_root[_T("data")] = weather_data;
            
            // Serialize to string
            wxJSONWriter writer;
            wxString response;
            writer.Write(response_root, response);
            
            // Send response
            SendPluginMessage(_T("WEATHER_DATA_RESPONSE"), response);
        }
    }
}
----

=== Broadcast Pattern

In this pattern, a plugin broadcasts information to all interested plugins without expecting a response:

[source,cpp]
----
// Broadcast vessel position
void PositionPlugin::BroadcastPosition() {
    // Create position message
    wxString position = wxString::Format(
        _T("lat=%.6f;lon=%.6f;cog=%.1f;sog=%.1f;timestamp=%ld"),
        m_current_lat, m_current_lon, m_current_cog, m_current_sog,
        wxDateTime::Now().GetTicks());
    
    // Broadcast to all plugins
    SendPluginMessage(_T("VESSEL_POSITION_BROADCAST"), position);
}
----

=== Plugin API Extension Pattern

In this pattern, a plugin exposes a rich API through the messaging system, allowing other plugins to interact with its features:

[source,cpp]
----
// Plugin exposing API functions
void RoutingPlugin::SetPluginMessage(wxString &message_id, wxString &message_body) {
    if (message_id == _T("ROUTING_API")) {
        // Parse API request
        wxJSONValue request;
        wxJSONReader reader;
        
        int errors = reader.Parse(message_body, &request);
        if (errors > 0) return;
        
        // Process API command
        if (request.HasMember(_T("command"))) {
            wxString command = request[_T("command")].AsString();
            
            if (command == _T("calculate_route")) {
                // Extract parameters
                double start_lat = request[_T("start_lat")].AsDouble();
                double start_lon = request[_T("start_lon")].AsDouble();
                double end_lat = request[_T("end_lat")].AsDouble();
                double end_lon = request[_T("end_lon")].AsDouble();
                
                // Calculate route
                RouteResult result = CalculateRoute(start_lat, start_lon, end_lat, end_lon);
                
                // Build response
                wxJSONValue response;
                response[_T("success")] = result.success;
                response[_T("message")] = result.message;
                
                if (result.success) {
                    // Add route points
                    wxJSONValue points;
                    for (size_t i = 0; i < result.points.size(); i++) {
                        wxJSONValue point;
                        point[_T("lat")] = result.points[i].lat;
                        point[_T("lon")] = result.points[i].lon;
                        points.Append(point);
                    }
                    response[_T("points")] = points;
                    response[_T("distance")] = result.total_distance;
                    response[_T("time")] = result.estimated_time;
                }
                
                // Serialize and send response
                wxJSONWriter writer;
                wxString response_str;
                writer.Write(response, response_str);
                
                SendPluginMessage(_T("ROUTING_API_RESPONSE"), response_str);
            }
            // Other API commands...
        }
    }
}
----

== Plugin Discovery

In some cases, plugins need to discover what other plugins are available and what capabilities they support. This can be done through a discovery protocol:

=== Plugin Advertising

When a plugin starts, it can advertise its presence and capabilities:

[source,cpp]
----
void MyPlugin::Init() {
    // ... other initialization
    
    // Advertise plugin presence and capabilities
    wxJSONValue capabilities;
    capabilities[_T("name")] = _T("MyPlugin");
    capabilities[_T("version")] = _T("1.2.3");
    capabilities[_T("api_version")] = _T("1.0");
    
    // List supported features
    wxJSONValue features;
    features.Append(_T("weather_data"));
    features.Append(_T("routing"));
    capabilities[_T("features")] = features;
    
    // List supported message types
    wxJSONValue messages;
    messages.Append(_T("WEATHER_DATA_REQUEST"));
    messages.Append(_T("WEATHER_FORECAST_V1"));
    capabilities[_T("messages")] = messages;
    
    // Serialize to string
    wxJSONWriter writer;
    wxString advert;
    writer.Write(capabilities, advert);
    
    // Broadcast capabilities
    SendPluginMessage(_T("PLUGIN_ADVERTISE"), advert);
}
----

=== Plugin Discovery

Other plugins can listen for these advertisements:

[source,cpp]
----
void MyOtherPlugin::SetPluginMessage(wxString &message_id, wxString &message_body) {
    if (message_id == _T("PLUGIN_ADVERTISE")) {
        // Parse advertisement
        wxJSONValue capabilities;
        wxJSONReader reader;
        
        int errors = reader.Parse(message_body, &capabilities);
        if (errors > 0) return;
        
        // Check if this plugin has features we need
        if (capabilities.HasMember(_T("features"))) {
            bool has_weather = false;
            wxJSONValue features = capabilities[_T("features")];
            
            for (int i = 0; i < features.Size(); i++) {
                if (features[i].AsString() == _T("weather_data")) {
                    has_weather = true;
                    break;
                }
            }
            
            if (has_weather) {
                // Found a plugin that provides weather data
                m_weather_plugin_name = capabilities[_T("name")].AsString();
                m_weather_plugin_found = true;
                
                // Now we know we can use WEATHER_DATA_REQUEST messages
            }
        }
    }
}
----

== REST API Integration

From API version 1.19, the plugin messaging system also integrates with OpenCPN's REST interface. This means:

* Messages from external applications via REST can be received by plugins
* Plugins can send messages that will be forwarded to REST clients

This enables integration with web applications, mobile apps, and other external systems.

=== Receiving REST Messages

REST messages appear as normal plugin messages with special message IDs:

[source,cpp]
----
void MyPlugin::SetPluginMessage(wxString &message_id, wxString &message_body) {
    // Check if this is a REST message
    if (message_id.StartsWith(_T("REST."))) {
        // Extract the REST endpoint from the message ID
        wxString endpoint = message_id.Mid(5);  // Skip "REST."
        
        // Process REST request
        if (endpoint == _T("myplugin/data")) {
            // Handle data request
            ProcessRestDataRequest(message_body);
        }
        else if (endpoint == _T("myplugin/command")) {
            // Handle command
            ProcessRestCommand(message_body);
        }
    }
}
----

=== Responding to REST Messages

To send a response back to a REST client, use a corresponding response message ID:

[source,cpp]
----
void MyPlugin::ProcessRestDataRequest(const wxString &request_body) {
    // Create response data
    wxJSONValue response;
    response[_T("status")] = _T("ok");
    response[_T("data")] = CreateDataResponse();
    
    // Serialize to string
    wxJSONWriter writer;
    wxString response_str;
    writer.Write(response, response_str);
    
    // Send response back to REST client
    SendPluginMessage(_T("REST.myplugin/data"), response_str);
}
----

== Best Practices

=== Performance Considerations

* **Message Size**: Keep messages small when possible
* **Message Frequency**: Avoid sending messages too frequently
* **Processing Time**: Keep message processing fast to avoid delays
* **Batching**: Batch updates when multiple changes occur in quick succession

=== Error Handling

* **Validate Input**: Always validate incoming message data
* **Error Responses**: Use clear error responses for invalid requests
* **Timeouts**: Implement timeouts for request-response patterns
* **Versioning**: Include version information in messages for compatibility

=== Message Design

* **Clear IDs**: Use descriptive, namespaced message IDs
* **Structured Data**: Use JSON or XML for complex data
* **Minimal Data**: Only include necessary information
* **Documentation**: Document your message formats for other developers

=== Security Considerations

* **Validation**: Always validate message data before using it
* **Sensitive Data**: Be careful with sensitive information in messages
* **Permissions**: Consider implementing permission checks for critical operations
* **Rate Limiting**: Protect against message flooding
